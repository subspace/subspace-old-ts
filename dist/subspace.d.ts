/// <reference types="node" />
import EventEmitter from 'events';
import Wallet from '@subspace/wallet';
import Storage from '@subspace/storage';
import Network from '@subspace/network';
import { Tracker } from '@subspace/tracker';
import { Ledger } from '@subspace/ledger';
import { DataBase, Record } from '@subspace/database';
import { INeighborProof, IPendingFailure } from './interfaces';
import { IGatewayNodeObject } from '@subspace/network';
import { IPledge } from '@subspace/wallet';
export default class Subspace extends EventEmitter {
    name: string;
    email: string;
    passphrase: string;
    pledge: IPledge;
    interval: number;
    bootstrap: boolean;
    gateway_nodes: IGatewayNodeObject[];
    gateway_count: number;
    delegated: boolean;
    isInit: boolean;
    env: string;
    storageAdapter: string;
    storage: Storage;
    network: Network;
    wallet: Wallet;
    tracker: Tracker;
    database: DataBase;
    ledger: Ledger;
    pendingRequests: Map<string, Set<string>>;
    messages: Map<string, number>;
    neighbors: Set<string>;
    neighborProofs: Map<string, INeighborProof>;
    failedNeighbors: Map<string, boolean>;
    pendingFailures: Map<string, IPendingFailure>;
    evictedShards: Map<string, Set<string>>;
    isHosting: boolean;
    constructor(name?: string, email?: string, passphrase?: string, pledge?: IPledge, interval?: number, bootstrap?: boolean, gateway_nodes?: IGatewayNodeObject[], gateway_count?: number, delegated?: boolean);
    private addRequest;
    private removeRequest;
    private resolveRequest;
    private sendPutResponse;
    private sendGetResponse;
    private sendRevResponse;
    private sendDelResponse;
    private sendContractResponse;
    private getRequestSize;
    private startMessagePruner;
    private isGateway;
    private initEnv;
    private init;
    createProfile(options: any): Promise<void>;
    deleteProfile(): Promise<void>;
    join(): Promise<void>;
    leave(): Promise<void>;
    connect(nodeId: string): Promise<void>;
    disconnect(nodeId: string): Promise<void>;
    send(nodeId: string, message: any): Promise<void>;
    seedPlot(size: number): Promise<void>;
    getBalance(address?: string): number;
    sendCredits(amount: number, address: string): Promise<Record>;
    pledgeSpace(interval: number): Promise<Record>;
    private setPaymentTimer;
    private requestHostPayment;
    reserveSpace(name?: string, email?: string, passphrase?: string, spaceReserved?: number, ttl?: number, replicationFactor?: number): Promise<void>;
    createMutableContract(name?: string, email?: string, passphrase?: string, spaceReserved?: number, ttl?: number, replicationFactor?: number): Promise<{
        txRecord: Record;
        contractRecord: Record;
    }>;
    putContract(txRecord: Record, contractRecord: Record): Promise<{}>;
    put(content: any, encrypted: boolean): Promise<{}>;
    get(key: string): Promise<{}>;
    rev(key: string, update: any): Promise<{}>;
    del(key: string): Promise<{}>;
    private getLastBlockId;
    private getChain;
    private getBlockHeader;
    private getTx;
    private getLastBlock;
    private getLedger;
    startFarmer(): Promise<void>;
    stopFarmer(): void;
    connectToNeighbor(nodeId: string): Promise<void>;
    getShard(nodeId: string, shardId: string, contractRecordId: string): Promise<void>;
    joinHosts(): Promise<void>;
    private replciateShards;
    leaveHosts(): Promise<void>;
    onHostFailure(): Promise<void>;
}
