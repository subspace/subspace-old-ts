<!doctype html>
<head>
  <link rel="stylesheet" href="assets/bootstrap.min.css">
  <script src="assets/vue.js" charset="utf-8"></script>
  <script src="assets/vue-toasted.js" charset="utf-8"></script>
  <script src="dist/subspace.browser.js" charset="utf-8"></script>
</head>

<body>
  <div id="subspace-debugger" class="subspace-debugger">
    <header>
      <span class="logo"><img src="https://www.subspace.network/wp-content/uploads/2018/10/Asset-12-150x150.png" /></span>
      <span v-if="nodeId" class="node-id">⭐ {{ nodeId.substring(0,8) }}</span>
    </header>
    <div id="messages" class="messages" ref="messages">
      <ul class="list list-unstyled">
        <li v-for="message in messages" :class="['message', message === activeMessage ? 'active' :  null ]">
          <div v-if="message.type === 'error'">
            <span class="time">[{{ message.timestamp | formatTime }}]</span>
            {{ message }}
          </div>
          <div v-if="message.type === 'peer-connection'">
            <span class="time">[{{ message.timestamp | formatTime }}]</span>
            {{ message }}
          </div>
          <!-- <div v-if="message.type === 'applied-block'">
            <span class="time">[{{ message.timestamp | formatTime }}]</span>
            {{ message }}
          </div> -->
          <div v-else>
            <span class="time">[{{ message.timestamp | formatTime }}]</span>
            <span v-on:click="onPeerClick(message.sender)" class="message-sender" :style="`color:${message.sender === nodeId ? '#090' : peerColors[peers.indexOf(message.sender) % peers.length]}`">
              <span v-if="message.sender === nodeId">⭐️</span>{{ message.sender ? message.sender.substring(0,8) : '-' }}
            </span>
            {{ message.verb }}
            a
            <span v-on:click="onMessageClick(message)" class="message-type">
              {{ message.type }}
              <span v-if="message.type === 'block'">({{ message.data.data._key.substring(0,8) }})</span>
              <span v-else-if="message.type === 'applied-block'">{{ message.data[0]._key.substring(0,8) }}</span>
            </span>
            {{ message.class }}
          </div>
        </li>
      </ul>
    </div>
    <pre class="details" v-html="syntaxHighlight(jsonParseDeep(activeMessage))"></pre>
  </div>

<script>
  Vue.use(Toasted)

  new Vue({
    el: '#subspace-debugger',

    data: {
      activeMessage: {},
      config: {
        blockTime: 10000,
        genesisAddress: '772441c914c75d64a3a7af3b2fd9c367ce6fe5c00450a43efe557c544e479de6:127.0.0.1:8125:8225',
        hostname: 'localhost',
        plotSizeBytes: 100000000000, // TODO: this is bytes, correct?
        tcpPort: 8126,
        wsPort: 8226,
      },
      messages: [],
      nodeId: null,
      peers: [],
      peerColors: [
        '#099',
        '#909',
        '#900',
        '#990',
      ],
      subspace: null,
    },

    computed: {
    },

    filters: {
      formatTime(value) {
        return [
          new Date(value).getHours().toString().padStart(2, '0'),
          new Date(value).getMinutes().toString().padStart(2, '0'),
          new Date(value).getSeconds().toString().padStart(2, '0'),
        ].join(':')
      },

      pretty(value) {
        return JSON.stringify(value, null, 2);
      },
    },

    methods: {
      addPeer(peer) {
        if (!this.peers.includes(peer)) {
          this.peers.push(peer)
        }
      },

      array2hex(array) {
        let string, i$, len$, byte
        string = ''
        for (i$ = 0, len$ = array.length; i$ < len$; ++i$) {
          byte = array[i$]
          string += byte.toString(16).padStart(2, '0')
        }
        return string
      },

      log(message) {
        if (message.type === 'error') {
          this.$toasted.show(
            'Error', {
              className: 'error',
              action: {
                text: 'Close',
                onClick: (e, toastObject) => {
                  toastObject.goAway(0)
                },
              },
            }
          )
        } else if (message.type === 'peer-connection') {
          this.$toasted.show(
            'Peer connected', {
              className: 'info',
              action: {
                text: 'Close',
                onClick: (e, toastObject) => {
                  toastObject.goAway(0)
                },
              },
            }
          )
        } else if (message.type === 'applied-block') {
          if (message.sender === this.nodeId) {
            this.$toasted.show(
              `Block ${message.data[0]._key.substring(0,8)} accepted`, {
                className: 'success',
                action: [
                  {
                    text: 'View',
                    onClick: (e, toastObject) => {
                      this.activeMessage = message
                    },
                  },
                  {
                    text: 'Close',
                    onClick: (e, toastObject) => {
                      toastObject.goAway(0)
                    },
                  }
                ],
              }
            )
          }
        }

        // allow 10px inaccuracy
        const messagesEl = this.$refs.messages
        const isScrolledToBottom = messagesEl && messagesEl.scrollHeight - messagesEl.clientHeight <= messagesEl.scrollTop + 20
        if (message.type === 'join') {
          debugger
        } else if (message.type === 'peer-added') {
          const decoder = new TextDecoder('utf-8')
          message.data.publicKey = decoder.decode(message.data.publicKey)
          message.data.signature = decoder.decode(message.data.signature)
          message.data.payload = this.array2hex(message.data.payload)
        } else if (message.type === 'peer-removed') {
          debugger
        }

        this.messages.push(message)

        if (isScrolledToBottom) {
          messagesEl.scrollTop = messagesEl.scrollHeight
        }
      },

      onMessageClick(message) {
        this.activeMessage = message
      },

      jsonParseDeep(o) {
        Object.keys(o).forEach(key => {
          if (o[key] !== null && typeof(o[key]) === "object") {
            o[key] = this.jsonParseDeep(o[key])
          }

          try {
            const obj = JSON.parse(o[key])
            o[key] = this.jsonParseDeep(obj)
          } catch (e) {
            o[key] = o[key]
          }
        })

        return o
      },

      formatKey(str, depth) {
        const indent = 4
        return `<span class='key'>${str.padStart(str.length + depth * indent, ' ')}</span>`
      },

      formatVal(val, depth) {
        if (typeof val === 'string') {
          // If it's a multi-line string, like a PGP key
          if (val.match(/\r\n/)) {
            val = '\n' + val.split(/\r\n/).map(row => row.padStart(row.length + (depth - 1) * 4)).join('\r\n')
          }
          return `<span class='string'>"${val}"</span>`
        } else if (typeof val === 'number') {
          return `<span class='number'>${val}</span>`
        } else if (typeof val === 'boolean') {
          return `<span class='boolean'>${val}</span>`
        } else if (val === null) {
          return `<span class='null'>${val}</span>`
        } else {
          return `<span>${val}</span>`
        }
      },

      syntaxHighlight(o, depth) {
        if (typeof depth === 'undefined') {
          depth = 1
        }

        const indent = 4

        let str = ''
        if (Array.isArray(o)) {
          str += '[\n'
          o.forEach(el => {
            const val = this.syntaxHighlight(el, depth + 1)
            str += `${val.padStart(val.length + (depth - 1) * indent + 2)},\n`
          })
          str += ']'.padStart((depth - 1) * indent + 1, ' ')
        } else if (typeof o === 'object' && o !== null) {
          str += '{\n'
          Object.keys(o).forEach(key => {
            str += this.formatKey(`"${key}": `, depth)
            str += `${this.syntaxHighlight(o[key], depth + 1)},\n`
          })
          str += '}'.padStart((depth - 1) * indent + 1, ' ')
        } else {
          str += this.formatVal(o, depth + 1)
        }

        return str
      },
    },

    async mounted() {
      // this.log({
      //   type: 'error',
      //   timestamp: Date.now(),
      // })
      // this.log({
      //   type: 'peer-connection',
      //   timestamp: Date.now(),
      // })

      this.subspace = new Subspace.default(false, [this.config.genesisAddress], 1)
      await this.subspace.init('browser', false)

      this.nodeId = this.subspace.wallet.getProfile().id

      this.subspace.on('connection', connection => {
        alert('new connection')
        debugger

        this.log({
          type: 'connection',
          sender: sender,
          timestamp: message.timestamp,
          verb: message.sender,
          class: 'message',
          data: message,
        })
      })

      // this.subspace.on('disconnection', nodeId => this.messages.push(`Lost connection to ${nodeId}`))
      // this.subspace.on('joined', () => this.log(`Joined the network with id ${this.nodeId.substring(0,8)}`))
      const messageTypes = [
        'message',
        'sent',
      ]

      messageTypes.forEach(messageType => {
        this.subspace.on(messageType, (sender, type, message) => {
          this.addPeer(sender)
          let binaryType = null

          this.log({
            type: type,
            sender: sender,
            timestamp: message.timestamp,
            verb: message.sender === this.nodeId ? 'received' : 'sent',
            class: 'message',
            data: message,
          })
        })
      })

      const eventTypes = [
        'joined',
        'block',
        'applied-block',
        'joined-hosts',
        'host-added',
        'neighbor-added',
        'space-reserved',
      ]
      eventTypes.forEach(eventType => {
        this.subspace.on(eventType, (...args) => {
          console.log(`${eventType}: ${JSON.stringify(args)}`)
          this.log({
            type: eventType,
            sender: this.nodeId,
            timestamp: Date.now(),
            verb: 'emitted',
            class: 'event',
            data: args,
          })
        })
      })
      // this.subspace.on('joined-hosts', (neighbors, activeHosts, tracker) => {
      //   this.log(`Connected to ${neighbors} closest hosts out of ${activeHosts} active hosts`)
      //   this.log(`Tracker: ${tracker.values()}`)
      // })

      // this.subspace.on('host-added', (hostId) => {
      //   this.log(`GW node ${gatewayNodeId.substring(0,8)} added ${hostId.substring(0,8)} to tracker for valid join`)
      // })

      // this.subspace.on('neighbor-added', (neighborId) => {
      //   this.log(`GW node ${gatewayNodeId.substring(0,8)} connected to host-neighbor ${neighborId.substring(0,8)} and received proof signature`.yellow)
      // })

      // this.log(`Seeding ${this.config.plotSizeBytes} byte plot...`)
      await this.subspace.seedPlot(this.config.plotSizeBytes)

      // this.log('Joining network...')
      await this.subspace.join(0, this.config.hostname)

      // this.log('Starting farmer...')
      await this.subspace.startFarmer(this.config.blockTime)

      // this.log('Pledging space...')
      await this.subspace.pledgeSpace()
    }
  })
</script>
</body>

<style>
html,body {
  height: 100%;
}

body {
  padding-top: 40px;
}

.subspace-debugger {
  display: flex;
  flex-direction: row wrap;
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  box-shadow: 0 0 2px rgba(0,0,0,0.5);
  z-index: 1;
  position: fixed;
  backface-visibility: hidden;
  background-color: #fff;
  top: 0;
}

header .logo img {
  width: 30px;
  height: 30px;
  margin: 5px 0 5px 10px;
}

header .node-id {
  margin-right: 10px;
  color: #090;
}

.messages {
  width: 35%;
  height: 100vh;
  max-height: 100vh;
  overflow-y: auto;
  padding: 10px;

  background-color: #eee;
  font-family: monospace;
}

.messages .message {
  /* cursor: pointer; */
}
.messages .message .time {
  color: #999;
}
.messages .message .is-sender {
  color: #090;
}
.messages .message .message-sender {
  /* color: #009; */
  /* cursor: pointer; */
  /* text-decoration: underline; */
}
.messages .message .message-type {
  color: #009;
  cursor: pointer;
  text-decoration: underline;
}
.messages .message:hover {
  background-color: #ddd;
}
.messages .message.active {
  background-color: #ddd;
}

.details {
  width: 65%;
  padding: 10px;
  height: 100vh;
  margin: 0;
  max-height: 100vh;
  overflow-y: auto;
  border-left: 1px solid #ccc;
}

.string { color: green; }
.number { color: darkorange; }
.boolean { color: blue; }
.null { color: magenta; }
.key { color: red; }

.toasted-container {
  backface-visibility: hidden;
}

.toasted-container.top-right {
  top: 40px;
  right: 20px;
}

.toasted-container .toasted {
  /* width: 500px; */
}

.toasted-container .toasted.error {
  background-color: rgba(255,0,0,0.9);
}

.toasted-container .toasted.info {
  background-color: rgba(51,153,255,0.9);
}

.toasted-container .toasted.success {
  background-color: rgba(0,153,0, 0.9);
}

.toasted-container .toasted.toasted-primary .action {
  color: #fff;
}
</style>