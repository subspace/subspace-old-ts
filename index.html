<!doctype html>
<head>
  <link rel="stylesheet" href="assets/bootstrap.min.css">
  <script src="dist/subspace.browser.js" charset="utf-8"></script>
  <script src="assets/vue.js" charset="utf-8"></script>
</head>

<body>
  <div id="subspace-debugger">
    <!-- <div class="stats">
      Node ID:
      <span v-if="nodeId">{{ nodeId.substring(0,8) }}</span>
      <br/>
      Plot size: {{ config.plotSizeBytes }} bytes
      <br/>
      Peers: ...
    </div> -->
    <div id="messages" class="messages" ref="messages">
      <ul class="list list-unstyled">
        <li v-for="message in messages" :class="['message', message === activeMessage ? 'active' :  null ]">
          <span class="time">[{{ message.timestamp | formatTime }}]</span>
          <span v-on:click="onPeerClick(message.sender)" class="message-sender" :style="`color:${message.sender === nodeId ? '#090' : peerColors[peers.indexOf(message.sender) % peers.length]}`">
            {{ message.sender ? message.sender.substring(0,8) : '-' }}
          </span>
          {{ message.verb }}
          a
          <span v-on:click="onMessageClick(message)" class="message-type">{{ message.type }}</span>
          {{ message.class }}
        </li>
      </ul>
    </div>
    <pre class="details" v-html="syntaxHighlight(activeMessage)"></pre>
  </div>

<script>
  new Vue({
    el: '#subspace-debugger',

    data: {
      activeMessage: {},
      config: {
        blockTime: 10000,
        genesisAddress: '772441c914c75d64a3a7af3b2fd9c367ce6fe5c00450a43efe557c544e479de6:127.0.0.1:8125:8225',
        hostname: 'localhost',
        plotSizeBytes: 100000000000, // TODO: this is bytes, correct?
        tcpPort: 8126,
        wsPort: 8226,
      },
      messages: [],
      nodeId: null,
      peers: [],
      peerColors: [
        '#099',
        '#909',
        '#900',
        '#990',
      ],
      subspace: null,
    },

    computed: {
    },

    filters: {
      formatTime(value) {
        return [
          new Date(value).getHours().toString().padStart(2, '0'),
          new Date(value).getMinutes().toString().padStart(2, '0'),
          new Date(value).getSeconds().toString().padStart(2, '0'),
        ].join(':')
      },

      pretty(value) {
        return JSON.stringify(value, null, 2);
      },
    },

    methods: {
      addPeer(peer) {
        if (!this.peers.includes(peer)) {
          this.peers.push(peer)
        }
      },

      log(message) {
        // allow 10px inaccuracy
        const messagesEl = this.$refs.messages
        const isScrolledToBottom = messagesEl && messagesEl.scrollHeight - messagesEl.clientHeight <= messagesEl.scrollTop + 20

        this.messages.push(message)

        if (isScrolledToBottom) {
          messagesEl.scrollTop = messagesEl.scrollHeight
        }
      },

      onMessageClick(message) {
        this.activeMessage = message
      },
    ///
    // function output(inp) {
    //   document.body.appendChild(document.createElement('pre')).innerHTML = inp;
    // }

// var str = JSON.stringify(obj, undefined, 4);
// output(syntaxHighlight(str));

      syntaxHighlight(json) {
        json = JSON.stringify(json, null, 4)
        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
          var cls = 'number';
          if (/^"/.test(match)) {
            if (/:$/.test(match)) {
              cls = 'key';
            } else {
              cls = 'string';

              try {
                match = JSON.parse(match)
                match = match.replace(/\n/g,"\n\t")
                match = match.replace(/,/g,",\n\t\t\t").replace(/\\r\\n/g,"\n\t\t")
                if (match.match(/^\{/)) {
                  match = match.replace(/^\{/, `{\n\t\t\t`)
                }
              } catch(e) {
                // do nothing
              }
            }
          } else if (/true|false/.test(match)) {
            cls = 'boolean';
          } else if (/null/.test(match)) {
            cls = 'null';
          }

          return '<span class="' + cls + '">' + match + '</span>';
        })
      },
    },

    async mounted() {
      this.subspace = new Subspace.default(false, [this.config.genesisAddress], 1)
      // this.network.on('message', async (id: Uint8Array, message: IMessage | Uint8Array, callback?: (message: Uint8Array) => void) => {
      // Subspace.ledger.on('block-solution', async (block) => {
      //   this.log(`block solution?? ${block}`)
      // })
      await this.subspace.init('browser', false)
      // this.subspace.network.on('message', (id, message) => {
      //   console.log('message:', id, message)
      // })

      this.nodeId = this.subspace.wallet.getProfile().id

      // this.subspace.on('connection', connection => this.jmessages.push(`Connected to ${connection}`))
      // this.subspace.on('disconnection', nodeId => this.messages.push(`Lost connection to ${nodeId}`))
      // this.subspace.on('joined', () => this.log(`Joined the network with id ${this.nodeId.substring(0,8)}`))
      const messageTypes = [
        'message',
        'sent',
      ]

      messageTypes.forEach(messageType => {
        this.subspace.on(messageType, (sender, type, message) => {
          this.addPeer(sender)
          let binaryType = null

          this.log({
            type: type,
            sender: sender,
            timestamp: message.timestamp,
            verb: message.sender === this.nodeId ? 'received' : 'sent',
            class: 'message',
            data: message,
          })
          // console.log('message:', message)
        })
      })

      const eventTypes = [
        'joined',
        'block',
        'applied-block',
        'joined-hosts',
        'host-added',
        'neighbor-added',
        'space-reserved',
      ]
      eventTypes.forEach(eventType => {
        this.subspace.on(eventType, (...args) => {
          console.log(`${eventType}: ${JSON.stringify(args)}`)
          this.log({
            type: eventType,
            sender: this.nodeId,
            timestamp: Date.now(),
            verb: 'emitted',
            class: 'event',
            data: args,
          })
        })
      })
      // this.subspace.on('joined-hosts', (neighbors, activeHosts, tracker) => {
      //   this.log(`Connected to ${neighbors} closest hosts out of ${activeHosts} active hosts`)
      //   this.log(`Tracker: ${tracker.values()}`)
      // })

      // this.subspace.on('host-added', (hostId) => {
      //   this.log(`GW node ${gatewayNodeId.substring(0,8)} added ${hostId.substring(0,8)} to tracker for valid join`)
      // })

      // this.subspace.on('neighbor-added', (neighborId) => {
      //   this.log(`GW node ${gatewayNodeId.substring(0,8)} connected to host-neighbor ${neighborId.substring(0,8)} and received proof signature`.yellow)
      // })

      // this.log(`Seeding ${this.config.plotSizeBytes} byte plot...`)
      // await this.subspace.seedPlot(this.config.plotSizeBytes)

      // this.log('Joining network...')
      await this.subspace.join(0, this.config.hostname)

      // this.log('Starting farmer...')
      // await this.subspace.startFarmer(this.config.blockTime)

      // this.log('Pledging space...')
      // await this.subspace.pledgeSpace()
    }
  })
</script>
</body>

<style>
html,body {
  height: 100%;
}
#subspace-debugger {
  display: flex;
}

.stats {
  width: 100%;
  padding: 10px;
}

.messages {
  width: 40%;
  height: 100vh;
  max-height: 100vh;
  overflow-y: auto;
  padding: 10px;

  background-color: #eee;
  font-family: monospace;
}

.messages .message {
  /* cursor: pointer; */
}
.messages .message .time {
  color: #999;
}
.messages .message .is-sender {
  color: #090;
}
.messages .message .message-sender {
  /* color: #009; */
  /* cursor: pointer; */
  /* text-decoration: underline; */
}
.messages .message .message-type {
  color: #009;
  cursor: pointer;
  text-decoration: underline;
}
.messages .message:hover {
  background-color: #f5f5f5;
}
.active {
  background-color: #ddd;
}

.details {
  width: 60%;
  padding: 10px;
  height: 100vh;
  max-height: 100vh;
  overflow-y: auto;
}

pre {outline: 1px solid #ccc; padding: 5px; margin: 5px; }
.string { color: green; }
.number { color: darkorange; }
.boolean { color: blue; }
.null { color: magenta; }
.key { color: red; }
</style>